import torch

import matplotlib.pyplot as plt
import imageio
import argparse

from model import DDPM

device = "mps" if torch.backends.mps.is_available() else "cpu"

T = 1000
betas = torch.linspace(1e-4, 0.02, T).to(device)
alphas = 1.0 - betas
alphas_cumprod = torch.cumprod(alphas.cpu(), axis=0).to(device)

@torch.no_grad()
def sample_image(model_path, digit=None):
    model = DDPM(
                image_size=32,
                bottleneck_dim=4,
                in_channels=1,
                out_dim=1,
                num_classes=10
                ).to(device)
    
    checkpoint = torch.load(model_path, map_location=device)
    model.load_state_dict(checkpoint["model_state_dict"])
    model.eval()

    # Setup the Condition (Label)
    if digit is not None:
        print(f"Generating specific digit: {digit}")
        y = torch.tensor([digit]).long().to(device)
    else:
        y = torch.randint(0, 10, (1,)).long().to(device)

    # Start from pure noise
    img = torch.randn(1, 1, 32, 32).to(device)

    frames = []
    for i in reversed(range(T)):
        t = torch.tensor([i], device=device).long()
        
        predicted_noise = model(img, t, y)

        # Coefficients
        beta = betas[i]
        alpha = alphas[i]
        alpha_hat = alphas_cumprod[i]

        if i > 0:
            noise = torch.randn_like(img)
        else:
            noise = torch.zeros_like(img)

        # The Reverse Equation (Langevin Dynamics)
        # Subtract the predicted noise to "clean" the image
        img = (1 / torch.sqrt(alpha)) * (img - ((1 - alpha) / (torch.sqrt(1 - alpha_hat))) * predicted_noise) + torch.sqrt(beta) * noise

        if i % 20 == 0 or i == 0:
            frame_tensor = (img.clamp(-1, 1) + 1) / 2
            frame_np = (frame_tensor * 255).type(torch.uint8).cpu().squeeze().numpy()
            frames.append(frame_np)

    final_img = frames[-1]
    plt.imsave("digit.png", final_img, cmap="gray")
    imageio.mimsave("diffusion_process.gif", frames, duration=0.1, loop=0)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--digit", type=int, default=None, help="Specific digit to be generated by the diffusion model")
    args = parser.parse_args()

    sample_image("diffusion_model_ema.pth", digit=args.digit)